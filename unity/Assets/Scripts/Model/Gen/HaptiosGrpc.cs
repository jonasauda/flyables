// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: Model/Protobuf/haptios.proto
// </auto-generated>
#pragma warning disable 0414, 1591
#region Designer generated code

using grpc = global::Grpc.Core;

namespace HaptiOS {
  public static partial class BlimpControlling
  {
    static readonly string __ServiceName = "HaptiOS.BlimpControlling";

    static readonly grpc::Marshaller<global::HaptiOS.Empty> __Marshaller_HaptiOS_Empty = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.Empty.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.BlimpList> __Marshaller_HaptiOS_BlimpList = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.BlimpList.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.BlimpIdentifier> __Marshaller_HaptiOS_BlimpIdentifier = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.BlimpIdentifier.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.BlimpStatus> __Marshaller_HaptiOS_BlimpStatus = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.BlimpStatus.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.BlimpControl> __Marshaller_HaptiOS_BlimpControl = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.BlimpControl.Parser.ParseFrom);

    static readonly grpc::Method<global::HaptiOS.Empty, global::HaptiOS.BlimpList> __Method_GetBlimps = new grpc::Method<global::HaptiOS.Empty, global::HaptiOS.BlimpList>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetBlimps",
        __Marshaller_HaptiOS_Empty,
        __Marshaller_HaptiOS_BlimpList);

    static readonly grpc::Method<global::HaptiOS.BlimpIdentifier, global::HaptiOS.BlimpStatus> __Method_GetBlimpInfo = new grpc::Method<global::HaptiOS.BlimpIdentifier, global::HaptiOS.BlimpStatus>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetBlimpInfo",
        __Marshaller_HaptiOS_BlimpIdentifier,
        __Marshaller_HaptiOS_BlimpStatus);

    static readonly grpc::Method<global::HaptiOS.BlimpControl, global::HaptiOS.Empty> __Method_MoveBlimp = new grpc::Method<global::HaptiOS.BlimpControl, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "MoveBlimp",
        __Marshaller_HaptiOS_BlimpControl,
        __Marshaller_HaptiOS_Empty);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::HaptiOS.HaptiosReflection.Descriptor.Services[0]; }
    }

    /// <summary>Base class for server-side implementations of BlimpControlling</summary>
    public abstract partial class BlimpControllingBase
    {
      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.BlimpList> GetBlimps(global::HaptiOS.Empty request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.BlimpStatus> GetBlimpInfo(global::HaptiOS.BlimpIdentifier request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> MoveBlimp(global::HaptiOS.BlimpControl request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for BlimpControlling</summary>
    public partial class BlimpControllingClient : grpc::ClientBase<BlimpControllingClient>
    {
      /// <summary>Creates a new client for BlimpControlling</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public BlimpControllingClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for BlimpControlling that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public BlimpControllingClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected BlimpControllingClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected BlimpControllingClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      public virtual global::HaptiOS.BlimpList GetBlimps(global::HaptiOS.Empty request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetBlimps(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.BlimpList GetBlimps(global::HaptiOS.Empty request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetBlimps, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.BlimpList> GetBlimpsAsync(global::HaptiOS.Empty request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetBlimpsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.BlimpList> GetBlimpsAsync(global::HaptiOS.Empty request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetBlimps, null, options, request);
      }
      public virtual global::HaptiOS.BlimpStatus GetBlimpInfo(global::HaptiOS.BlimpIdentifier request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetBlimpInfo(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.BlimpStatus GetBlimpInfo(global::HaptiOS.BlimpIdentifier request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetBlimpInfo, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.BlimpStatus> GetBlimpInfoAsync(global::HaptiOS.BlimpIdentifier request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetBlimpInfoAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.BlimpStatus> GetBlimpInfoAsync(global::HaptiOS.BlimpIdentifier request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetBlimpInfo, null, options, request);
      }
      public virtual global::HaptiOS.Empty MoveBlimp(global::HaptiOS.BlimpControl request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return MoveBlimp(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty MoveBlimp(global::HaptiOS.BlimpControl request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_MoveBlimp, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> MoveBlimpAsync(global::HaptiOS.BlimpControl request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return MoveBlimpAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> MoveBlimpAsync(global::HaptiOS.BlimpControl request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_MoveBlimp, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override BlimpControllingClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new BlimpControllingClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(BlimpControllingBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_GetBlimps, serviceImpl.GetBlimps)
          .AddMethod(__Method_GetBlimpInfo, serviceImpl.GetBlimpInfo)
          .AddMethod(__Method_MoveBlimp, serviceImpl.MoveBlimp).Build();
    }

    /// <summary>Register service method implementations with a service binder. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, BlimpControllingBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_GetBlimps, serviceImpl.GetBlimps);
      serviceBinder.AddMethod(__Method_GetBlimpInfo, serviceImpl.GetBlimpInfo);
      serviceBinder.AddMethod(__Method_MoveBlimp, serviceImpl.MoveBlimp);
    }

  }
  public static partial class BlimpBroadcast
  {
    static readonly string __ServiceName = "HaptiOS.BlimpBroadcast";

    static readonly grpc::Marshaller<global::HaptiOS.BlimpList> __Marshaller_HaptiOS_BlimpList = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.BlimpList.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.Empty> __Marshaller_HaptiOS_Empty = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.Empty.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.BlimpStatus> __Marshaller_HaptiOS_BlimpStatus = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.BlimpStatus.Parser.ParseFrom);

    static readonly grpc::Method<global::HaptiOS.BlimpList, global::HaptiOS.Empty> __Method_SendBlimps = new grpc::Method<global::HaptiOS.BlimpList, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendBlimps",
        __Marshaller_HaptiOS_BlimpList,
        __Marshaller_HaptiOS_Empty);

    static readonly grpc::Method<global::HaptiOS.BlimpStatus, global::HaptiOS.Empty> __Method_SendStatus = new grpc::Method<global::HaptiOS.BlimpStatus, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendStatus",
        __Marshaller_HaptiOS_BlimpStatus,
        __Marshaller_HaptiOS_Empty);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::HaptiOS.HaptiosReflection.Descriptor.Services[1]; }
    }

    /// <summary>Base class for server-side implementations of BlimpBroadcast</summary>
    public abstract partial class BlimpBroadcastBase
    {
      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> SendBlimps(global::HaptiOS.BlimpList request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> SendStatus(global::HaptiOS.BlimpStatus request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for BlimpBroadcast</summary>
    public partial class BlimpBroadcastClient : grpc::ClientBase<BlimpBroadcastClient>
    {
      /// <summary>Creates a new client for BlimpBroadcast</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public BlimpBroadcastClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for BlimpBroadcast that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public BlimpBroadcastClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected BlimpBroadcastClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected BlimpBroadcastClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      public virtual global::HaptiOS.Empty SendBlimps(global::HaptiOS.BlimpList request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendBlimps(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty SendBlimps(global::HaptiOS.BlimpList request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendBlimps, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> SendBlimpsAsync(global::HaptiOS.BlimpList request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendBlimpsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> SendBlimpsAsync(global::HaptiOS.BlimpList request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendBlimps, null, options, request);
      }
      public virtual global::HaptiOS.Empty SendStatus(global::HaptiOS.BlimpStatus request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendStatus(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty SendStatus(global::HaptiOS.BlimpStatus request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendStatus, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> SendStatusAsync(global::HaptiOS.BlimpStatus request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendStatusAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> SendStatusAsync(global::HaptiOS.BlimpStatus request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendStatus, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override BlimpBroadcastClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new BlimpBroadcastClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(BlimpBroadcastBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_SendBlimps, serviceImpl.SendBlimps)
          .AddMethod(__Method_SendStatus, serviceImpl.SendStatus).Build();
    }

    /// <summary>Register service method implementations with a service binder. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, BlimpBroadcastBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_SendBlimps, serviceImpl.SendBlimps);
      serviceBinder.AddMethod(__Method_SendStatus, serviceImpl.SendStatus);
    }

  }
  public static partial class VirtualWorld
  {
    static readonly string __ServiceName = "HaptiOS.VirtualWorld";

    static readonly grpc::Marshaller<global::HaptiOS.Empty> __Marshaller_HaptiOS_Empty = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.Empty.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.GameObjectList> __Marshaller_HaptiOS_GameObjectList = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.GameObjectList.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.GameObjectBlimpStatus> __Marshaller_HaptiOS_GameObjectBlimpStatus = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.GameObjectBlimpStatus.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.GameObject> __Marshaller_HaptiOS_GameObject = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.GameObject.Parser.ParseFrom);

    static readonly grpc::Method<global::HaptiOS.Empty, global::HaptiOS.GameObjectList> __Method_GetObjects = new grpc::Method<global::HaptiOS.Empty, global::HaptiOS.GameObjectList>(
        grpc::MethodType.Unary,
        __ServiceName,
        "GetObjects",
        __Marshaller_HaptiOS_Empty,
        __Marshaller_HaptiOS_GameObjectList);

    static readonly grpc::Method<global::HaptiOS.GameObjectBlimpStatus, global::HaptiOS.Empty> __Method_SendBlimpStatus = new grpc::Method<global::HaptiOS.GameObjectBlimpStatus, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "SendBlimpStatus",
        __Marshaller_HaptiOS_GameObjectBlimpStatus,
        __Marshaller_HaptiOS_Empty);

    static readonly grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty> __Method_OnTakeOff = new grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "OnTakeOff",
        __Marshaller_HaptiOS_GameObject,
        __Marshaller_HaptiOS_Empty);

    static readonly grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty> __Method_OnLand = new grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "OnLand",
        __Marshaller_HaptiOS_GameObject,
        __Marshaller_HaptiOS_Empty);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::HaptiOS.HaptiosReflection.Descriptor.Services[2]; }
    }

    /// <summary>Base class for server-side implementations of VirtualWorld</summary>
    public abstract partial class VirtualWorldBase
    {
      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.GameObjectList> GetObjects(global::HaptiOS.Empty request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> SendBlimpStatus(global::HaptiOS.GameObjectBlimpStatus request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> OnTakeOff(global::HaptiOS.GameObject request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> OnLand(global::HaptiOS.GameObject request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for VirtualWorld</summary>
    public partial class VirtualWorldClient : grpc::ClientBase<VirtualWorldClient>
    {
      /// <summary>Creates a new client for VirtualWorld</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public VirtualWorldClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for VirtualWorld that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public VirtualWorldClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected VirtualWorldClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected VirtualWorldClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      public virtual global::HaptiOS.GameObjectList GetObjects(global::HaptiOS.Empty request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetObjects(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.GameObjectList GetObjects(global::HaptiOS.Empty request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_GetObjects, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.GameObjectList> GetObjectsAsync(global::HaptiOS.Empty request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return GetObjectsAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.GameObjectList> GetObjectsAsync(global::HaptiOS.Empty request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_GetObjects, null, options, request);
      }
      public virtual global::HaptiOS.Empty SendBlimpStatus(global::HaptiOS.GameObjectBlimpStatus request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendBlimpStatus(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty SendBlimpStatus(global::HaptiOS.GameObjectBlimpStatus request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_SendBlimpStatus, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> SendBlimpStatusAsync(global::HaptiOS.GameObjectBlimpStatus request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return SendBlimpStatusAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> SendBlimpStatusAsync(global::HaptiOS.GameObjectBlimpStatus request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_SendBlimpStatus, null, options, request);
      }
      public virtual global::HaptiOS.Empty OnTakeOff(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OnTakeOff(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty OnTakeOff(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_OnTakeOff, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> OnTakeOffAsync(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OnTakeOffAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> OnTakeOffAsync(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_OnTakeOff, null, options, request);
      }
      public virtual global::HaptiOS.Empty OnLand(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OnLand(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty OnLand(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_OnLand, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> OnLandAsync(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return OnLandAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> OnLandAsync(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_OnLand, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override VirtualWorldClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new VirtualWorldClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(VirtualWorldBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_GetObjects, serviceImpl.GetObjects)
          .AddMethod(__Method_SendBlimpStatus, serviceImpl.SendBlimpStatus)
          .AddMethod(__Method_OnTakeOff, serviceImpl.OnTakeOff)
          .AddMethod(__Method_OnLand, serviceImpl.OnLand).Build();
    }

    /// <summary>Register service method implementations with a service binder. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, VirtualWorldBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_GetObjects, serviceImpl.GetObjects);
      serviceBinder.AddMethod(__Method_SendBlimpStatus, serviceImpl.SendBlimpStatus);
      serviceBinder.AddMethod(__Method_OnTakeOff, serviceImpl.OnTakeOff);
      serviceBinder.AddMethod(__Method_OnLand, serviceImpl.OnLand);
    }

  }
  public static partial class RealWorld
  {
    static readonly string __ServiceName = "HaptiOS.RealWorld";

    static readonly grpc::Marshaller<global::HaptiOS.GameObject> __Marshaller_HaptiOS_GameObject = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.GameObject.Parser.ParseFrom);
    static readonly grpc::Marshaller<global::HaptiOS.Empty> __Marshaller_HaptiOS_Empty = grpc::Marshallers.Create((arg) => global::Google.Protobuf.MessageExtensions.ToByteArray(arg), global::HaptiOS.Empty.Parser.ParseFrom);

    static readonly grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty> __Method_Start = new grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Start",
        __Marshaller_HaptiOS_GameObject,
        __Marshaller_HaptiOS_Empty);

    static readonly grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty> __Method_Stop = new grpc::Method<global::HaptiOS.GameObject, global::HaptiOS.Empty>(
        grpc::MethodType.Unary,
        __ServiceName,
        "Stop",
        __Marshaller_HaptiOS_GameObject,
        __Marshaller_HaptiOS_Empty);

    /// <summary>Service descriptor</summary>
    public static global::Google.Protobuf.Reflection.ServiceDescriptor Descriptor
    {
      get { return global::HaptiOS.HaptiosReflection.Descriptor.Services[3]; }
    }

    /// <summary>Base class for server-side implementations of RealWorld</summary>
    public abstract partial class RealWorldBase
    {
      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> Start(global::HaptiOS.GameObject request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

      public virtual global::System.Threading.Tasks.Task<global::HaptiOS.Empty> Stop(global::HaptiOS.GameObject request, grpc::ServerCallContext context)
      {
        throw new grpc::RpcException(new grpc::Status(grpc::StatusCode.Unimplemented, ""));
      }

    }

    /// <summary>Client for RealWorld</summary>
    public partial class RealWorldClient : grpc::ClientBase<RealWorldClient>
    {
      /// <summary>Creates a new client for RealWorld</summary>
      /// <param name="channel">The channel to use to make remote calls.</param>
      public RealWorldClient(grpc::Channel channel) : base(channel)
      {
      }
      /// <summary>Creates a new client for RealWorld that uses a custom <c>CallInvoker</c>.</summary>
      /// <param name="callInvoker">The callInvoker to use to make remote calls.</param>
      public RealWorldClient(grpc::CallInvoker callInvoker) : base(callInvoker)
      {
      }
      /// <summary>Protected parameterless constructor to allow creation of test doubles.</summary>
      protected RealWorldClient() : base()
      {
      }
      /// <summary>Protected constructor to allow creation of configured clients.</summary>
      /// <param name="configuration">The client configuration.</param>
      protected RealWorldClient(ClientBaseConfiguration configuration) : base(configuration)
      {
      }

      public virtual global::HaptiOS.Empty Start(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Start(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty Start(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Start, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> StartAsync(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return StartAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> StartAsync(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Start, null, options, request);
      }
      public virtual global::HaptiOS.Empty Stop(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return Stop(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual global::HaptiOS.Empty Stop(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.BlockingUnaryCall(__Method_Stop, null, options, request);
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> StopAsync(global::HaptiOS.GameObject request, grpc::Metadata headers = null, global::System.DateTime? deadline = null, global::System.Threading.CancellationToken cancellationToken = default(global::System.Threading.CancellationToken))
      {
        return StopAsync(request, new grpc::CallOptions(headers, deadline, cancellationToken));
      }
      public virtual grpc::AsyncUnaryCall<global::HaptiOS.Empty> StopAsync(global::HaptiOS.GameObject request, grpc::CallOptions options)
      {
        return CallInvoker.AsyncUnaryCall(__Method_Stop, null, options, request);
      }
      /// <summary>Creates a new instance of client from given <c>ClientBaseConfiguration</c>.</summary>
      protected override RealWorldClient NewInstance(ClientBaseConfiguration configuration)
      {
        return new RealWorldClient(configuration);
      }
    }

    /// <summary>Creates service definition that can be registered with a server</summary>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static grpc::ServerServiceDefinition BindService(RealWorldBase serviceImpl)
    {
      return grpc::ServerServiceDefinition.CreateBuilder()
          .AddMethod(__Method_Start, serviceImpl.Start)
          .AddMethod(__Method_Stop, serviceImpl.Stop).Build();
    }

    /// <summary>Register service method implementations with a service binder. Useful when customizing the service binding logic.
    /// Note: this method is part of an experimental API that can change or be removed without any prior notice.</summary>
    /// <param name="serviceBinder">Service methods will be bound by calling <c>AddMethod</c> on this object.</param>
    /// <param name="serviceImpl">An object implementing the server-side handling logic.</param>
    public static void BindService(grpc::ServiceBinderBase serviceBinder, RealWorldBase serviceImpl)
    {
      serviceBinder.AddMethod(__Method_Start, serviceImpl.Start);
      serviceBinder.AddMethod(__Method_Stop, serviceImpl.Stop);
    }

  }
}
#endregion
